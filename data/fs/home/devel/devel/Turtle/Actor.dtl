//NOGENERATOR
$=!create.
$:create=[|tag| (window:$) ! (root) (tag) call. ].
Actor=!create.
Actor:pos=Vec2:O.
Actor:dir=0.
Actor:num=[|x| [x]!then[x]else[0]execute ].
//Actor:actorList=Array! create.
Actor:createSVGElem=[|tag|
    $! (document !
    "http://www.w3.org/2000/svg" (tag)
    createElementNS
    ) create.
].
Actor:copySVGElem=[|dst src;t n a s|
    src=$!(src)create.
    dst=$!(dst)create.
    t=this.
    src ! children [
        s=this.
        n=t ! (s:tagName) createSVGElem  0 get.
        a=(t:Array:prototype:slice)! (s:attributes) call.
        a ! [|an|
            an=an:name.
            n ! (an) (s!(an) getAttribute) setAttribute.
        ] each.
        dst ! (n) append.
        t ! (n) (s) copySVGElem.
    ] each.
].
Actor:show=[
    group ! (this) add.
    !setTrans.
    isShowing=true.
    this.
].
Actor:hide=[|;i|
    group ! (this) remove.
    isShowing=false.
    this.
].
Actor!"show" "appear" addAlias "hide" "die" addAlias.
Actor:group=Actor !create.
Actor:group:members=Array!create.
Actor:group:remove=[|m;i|
    i=members ! (m) indexOf.
    [i>=0] ! then [
        members ! (i) (1) splice.
    ] execute.
    [m:element] ! then [m:element ! remove] execute.
].
Actor:group:add=[|m;i|
    [m:getCrashShape] ! then [] else [ system ! ("NO"+m) throw ]execute.
    i=members ! (m) indexOf.
    [i<0] ! then [
        members ! (m) push.
        element ! (m:element) append.
    ] execute.
].

Actor:initSVG=[|;t wndj wndw wndh htmlj htmlw htmlh |
    svg=$ ! "svg" create.
    console ! "SVG" (svg) log.
    wndj=$ ! (window) create.
    htmlj=:window!("html")$ 0 get.
    htmlw=(:window!(htmlj:scrollWidth)parseFloat)-10.
    htmlh=(:window!(htmlj:scrollHeight)parseFloat)-10.
    wndw=(wndj ! width)-10.
    wndh=(wndj ! height)-10.
    [wndh<=0] ! then [wndh=wndw/16*9] execute.
    [htmlh<=0] ! then [htmlh=htmlw/16*9] execute.
    [svg:length==0] ! then [
        //window ! (svgw+","+svgh) alert.
        svg= !"svg" createSVGElem
        "id" "turtle_svg" attr
        "width" (htmlw) attr
        "height" (htmlh) attr
        "position" "absolute" css
        "body" appendTo.
    ] execute.
    svg_g = svg ! "g" find.
    [svg_g:length==0] ! then [
        svg_g= ! "g" createSVGElem
        "transform" ("translate("+(wndw/2)+","+(wndh/2)+") scale(1,-1)") attr
        (svg) appendTo.
    ] execute.
    t=self.
    t:htmlResize=[|htmlw htmlh|
        [htmlh<=0] ! then [htmlh=htmlw/16*9] execute.
        (t:svg) ! "width" (htmlw) attr "height" (htmlh) attr.
    ].
    :window ! ([|;htmlw htmlh wndw wndh|
        htmlw=(:window!(htmlj:scrollWidth)parseFloat)-10.
        htmlh=(:window!(htmlj:scrollHeight)parseFloat)-10.
        htmlw_old=:window!((t:svg)!"width"attr)parseFloat.
        htmlh_old=:window!((t:svg)!"height"attr)parseFloat.
        [
            or!(htmlw!=htmlw_old)(htmlh!=htmlh_old)true
        ]!then[
            t:htmlResize!(htmlw)(htmlh)execute.
        ]execute.
    ] !(this)bind) 100 setInterval.
    wndj ! [
        wndw=(wndj ! width)-10.
        wndh=(wndj ! height)-10.
        [wndh<=0] ! then [wndh=wndw/16*9] execute.
        (t:svg_g) !"transform" ("translate("+(wndw/2)+","+(wndh/2)+") scale(1,-1)") attr.
    ] resize.
    group:element=svg_g.
].
Actor! initSVG.

// element pos dir
Actor:forward=[|by|
    by=!(by) num.
    _lastPos=pos.
    _lastStep=by.
    pos=pos ! ((Vec2:X) ! (dir) rotate (by) mul) add.
    !setTrans.
    this.
].
Actor:backward=[|by|
    by=!(by) num.
    ! (-by) forward.
].
Actor:turnLeft=[|by|
    by=!(by) num.
    dir=dir+by.
    !setTrans.
    this.
].
Actor:turnRight=[|by|
    by=!(by) num.
    ! (-by) turnLeft.
].
Actor:leftTurn=Actor:turnLeft.
Actor:rightTurn=Actor:turnRight.

Actor:getCrashShape=[
    Polygon ! create
    (-width/2) (-height/2) addVertex
    (width/2) (-height/2) addVertex
    (width/2) (height/2) addVertex
    (-width/2) (height/2) addVertex
    (dir) (pos) transform.
].
//Actor:getCrashPolygon=[
    //    ! getWorldPolygon toPolyKArray.
//].
Actor:crashTo=[|o|
    [o:getCrashShape] ! then [] else [ system ! ("NO"+o) throw ]execute.
    
    (!getCrashShape) ! (o ! getCrashShape) intersects.
    //    (window:PolyK) ! (! getCrashPolygon) (o ! getCrashPolygon) Intersects.
].
Actor:_scale=1.
Actor:setTrans=[|str|
    str="translate("+(pos:x)+" "+(pos:y)+") ".
    str=str+"rotate("+dir+") ".
    str=str+"scale("+_scale+" "+_scale+") ".
    element ! "transform" (str) attr
    "data-trans" ((pos:x)+","+(pos:y)+","+dir) attr.
    [isShowing] !then [! checkCrash] execute.
    this.
].
Actor:scale=[|s| _scale=_scale*s.!setTrans].
Actor:moveTo=[|dx dy|
    dx=!(dx) num.dy=!(dy) num.
    pos=Vec2 !(dx)(dy) create.
    ! setTrans
].
Actor:moveToCenter=[
    !0 0 moveTo.
].
Actor!"moveToCenter" "moveCenter" addAlias.

Actor:moveBy=[|dx dy|
    dx=!(dx) num.dy=!(dy) num.
    ! (pos:x+dx) (pos:y+dy) moveTo
].
Actor:setDir=[|d|
    dir=!(d) num.
    !setTrans
].
Actor ! "setDir" "direction" addAlias.
Actor:getDir=[dir].
Actor ! "getDir" "direction?" addAlias.
//Actor ! "collision" addEventType.// ★
:collision=[].
:collision:isEventHandler=true.

Actor:checkCrash=[|;t|
    [Actor:_doingCheckCrash] ! then [] else [
        Actor:_doingCheckCrash=1.//TODO:true
        !allCrash [|a|
            ! (a) collision.
            a ! (this) collision.
        ] each. //TODO: localize
        Actor:_doingCheckCrash=0.
    ] execute.
].
Actor:allCrash=[|;t res|
    res=Array ! create.
    (group:members) ! [|a|
        [this!=a] ! then [
            [! (a) crashTo] ! then [
                res!(a) push.
            ] execute.
        ] execute.
    ] each.
    res.
].
Actor:bounce＝[| _hitTarget; lp ld stp a |
    lp=_lastPos.ld=dir.
    stp=lp ! (pos) sub len.
    pos=lp.
    a=2*( dir - ( _hitTarget ! getDir ) ).
    ! (a) turnRight.
    ! ( stp ) forward.
    [(! allCrash):length] ! then [
        pos=lp. dir=ld.
        ! ( 180- a ) turnLeft.
        ! ( stp ) forward.
        [(! allCrash):length] ! then [
            pos=lp. dir=ld.
            ! 180 turnLeft.
        ] execute.
    ] execute.
    self
].
Actor:xpos?=[pos:x].
Actor:ypos?=[pos:y].
